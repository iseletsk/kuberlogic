name: Integration tests

on:
  pull_request:
    branches: [ master ]
  push:
    branches: [ master ]

jobs:
  test:
    if: "!contains(github.event.commits[0].message, '[skip ci]')"
    name: Integration tests
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      matrix:
        include:
          - type: postgresql
            pg_version: 13

#          - type: postgresql
#            pg_version: 12

#          - type: postgresql
#            pg_version: 11

#          - type: postgresql
#            pg_version: 10

#          - type: postgresql
#            pg_version: 9.6

#          - type: postgresql
#            pg_version: 9.5

#          - type: postgresql
#            pg_version: 9.4
#
#          - type: postgresql
#            pg_version: 9.3

          - type: mysql
            my_version: 5.7.31

#          - type: mysql
#            my_version: 5.7.29

#          - type: mysql
#            my_version: 5.7.26

#          - type: mysql
#            my_version: 5.7.24

#         - type: mysql
#            version: 8.0.20
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Setup Git credentials
        run: |
          git config --global url."https://$PRIVATE_GITHUB_TOKEN:x-oauth-basic@github.com/kuberlogic".insteadOf "https://github.com/kuberlogic"
        env:
          PRIVATE_GITHUB_TOKEN: ${{ secrets.PRIVATE_GITHUB_TOKEN }}

      - name: Get dependencies for the apiserver
        working-directory: ./modules/apiserver
        env:
          GOPRIVATE: github.com/kuberlogic/*
        run: |
          go mod download

      - name: Setup Minikube
        uses: manusa/actions-setup-minikube@v2.3.0
        with:
          minikube version: 'v1.19.0'
          kubernetes version: 'v1.20.5'
          github token: ${{ secrets.GITHUB_TOKEN }}

          # It's need for the local usage for the webhook:
          # Turns on aggregator routing requests to endpoints IP rather than cluster IP.
          start args: --extra-config=apiserver.enable-aggregator-routing=true

      - name: Configure logs
        working-directory: ./modules/apiserver/tests
        run: |
          echo Your testid label value is $GITHUB_RUN_ID
          make configure-logs
        env:
          LOGZ_IO_TOKEN: ${{ secrets.LOGZ_IO_TOKEN }}
          LOGZ_IO_LISTENER: ${{ secrets.LOGZ_IO_LISTENER }}

      - name: Create secret of operator
        run: |
          kubectl create secret docker-registry kuberlogic-registry --docker-server=$REGISTRY_SERVER --docker-username=$REGISTRY_USER --docker-password=$REGISTRY_PASSWORD
        env:
          REGISTRY_SERVER: ${{ secrets.REGISTRY_SERVER }}
          REGISTRY_USER: ${{ secrets.REGISTRY_USER }}
          REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Deploy operator
        run: |
          make deploy-requirements
          make deploy

      - name: Setup minio for backup storage
        working-directory: ./modules/apiserver/tests
        run: |
          make deploy-minio

      - name: Waiting ready the pods
        run: |
          kubectl wait --for=condition=Ready pods --all --timeout=5m

      - name: Show pod status
        run: |
          kubectl logs -l app=minio
          docker images
        if: ${{ failure() }}

      - name: Create test bucket (backup storage)
        working-directory: ./modules/apiserver/tests
        run: |
          make create-bucket

      - name: PATCH - Remove operator, creating certs, change endpoint for ability using webhook locally in the tests
        working-directory: ./modules/apiserver/tests
        run: |
          make undeploy-operator generate-local-webhook-certs patch-endpoint
          kubectl get endpoints

      - name: Ensure keycloak is ready
        working-directory: ./modules/apiserver/tests/config
        run: |
          ./wait-for-keycloak.sh

      - name: Run the tests with coverage
        working-directory: ./modules/apiserver/tests
        run: |
          KUBERLOGIC_AUTH_KEYCLOAK_URL=https://$(kubectl get svc keycloak -o jsonpath='{.spec.clusterIP}'):8443 GODEBUG=x509ignoreCN=0 KUBERLOGIC_KUBECONFIGPATH=${HOME}/.kube/config make coverage-report RUN=/$TYPE
        env:
          KUBERLOGIC_AUTH_PROVIDER: keycloak
          KUBERLOGIC_AUTH_KEYCLOAK_CLIENTID: apiserver
          KUBERLOGIC_AUTH_KEYCLOAK_CLIENT_SECRET: apiserver-secret
          KUBERLOGIC_AUTH_KEYCLOAK_REALM_NAME: kuberlogic_realm
          PG_VERSION: ${{ matrix.pg_version }}
          MY_VERSION: ${{ matrix.my_version }}
          TYPE: ${{ matrix.type }}

      - name: Upload coverage
        run: |
          bash <(curl -s https://codecov.io/bash) -f modules/apiserver/tests/coverage-operator.out -F operator
          bash <(curl -s https://codecov.io/bash) -f modules/apiserver/tests/coverage-apiserver.out -F apiserver
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      - name: Show status
        run: |
          kubectl get pod,sts,deploy,svc,cj,job -o yaml
        if: ${{ failure() }}

      - name: Generating logs
        working-directory: ./modules/apiserver/tests
        run: |
          kubectl logs -l name=postgres-operator --tail=-1 > postgres-operator.log
          kubectl logs -l app=mysql-operator -c mysql-operator --tail=-1 > mysql-operator.log
          kubectl describe pod -l name=postgres-operator > postgres-operator.describe.log
          kubectl describe pod -l app=mysql-operator > mysql-operator.describe.log
          kubectl describe pod -l app=alertmanager > alertmanager.describe.log
          kubectl get pod > pods-status.log
          kubectl get endpoints > endpoints.log
          kubectl get services > services.log
          kubectl logs -l app.kubernetes.io/name=kube-state-metrics -c kube-state-metrics > kube-state-metrics.logs
          kubectl logs -l app.kubernetes.io/name=kube-state-metrics -c kube-rbac-proxy > kube-rbac-proxy.kube-state-metrics.logs
          kubectl get kuberlogicservice,kuberlogicbackupschedules,kuberlogicbackuprestores > kuberlogics-services.log
          kubectl describe pod -l app.kubernetes.io/name=mysql > mysql-cluster.describe.log
          kubectl describe pod -l application=spilo > pg-cluster.describe.log
          kubectl logs -l app.kubernetes.io/name=mysql -c mysql --tail=-1 > mysql-cluster.log
          kubectl logs -l application=spilo -c postgres --tail=-1 > pg-cluster.log
        if: ${{ always() }}
        continue-on-error: true

      - name: Archive logs
        uses: actions/upload-artifact@v2
        with:
          name: ${{ matrix.type }}-${{ matrix.pg_version }}${{ matrix.my_version }}-logs
          path: |
            ./modules/apiserver/tests/*.log
        if: ${{ always() }}
